/*
Name: iaf_psc_alpha - Leaky integrate-and-fire neuron model.

Description:

  iaf_psc_alpha is an implementation of a leaky integrate-and-fire model
  with alpha-function shaped synaptic currents. Thus, synaptic currents
  and the resulting post-synaptic potentials have a finite rise time.

  The threshold crossing is followed by an absolute refractory period
  during which the membrane potential is clamped to the resting potential.

  The linear subthresold dynamics is integrated by the Exact
  Integration scheme [1]. The neuron dynamics is solved on the time
  grid given by the computation step size. Incoming as well as emitted
  spikes are forced to that grid.

  An additional state variable and the corresponding differential
  equation represents a piecewise constant external current.

  The general framework for the consistent formulation of systems with
  neuron like dynamics interacting by point events is described in
  [1].  A flow chart can be found in [2].

  Critical tests for the formulation of the neuron model are the
  comparisons of simulation results for different computation step
  sizes. sli/testsuite/nest contains a number of such tests.

  The iaf_psc_alpha is the standard model used to check the consistency
  of the nest simulation kernel because it is at the same time complex
  enough to exhibit non-trivial dynamics and simple enough compute
  relevant measures analytically.

Remarks:

  The present implementation uses individual variables for the
  components of the state vector and the non-zero matrix elements of
  the propagator.  Because the propagator is a lower triangular matrix
  no full matrix multiplication needs to be carried out and the
  computation can be done "in place" i.e. no temporary state vector
  object is required.

  The template support of recent C++ compilers enables a more succinct
  formulation without loss of runtime performance already at minimal
  optimization levels. A future version of iaf_psc_alpha will probably
  address the problem of efficient usage of appropriate vector and
  matrix objects.

Remarks:

  If tau_m is very close to tau_syn_ex or tau_syn_in, the model
  will numerically behave as if tau_m is equal to tau_syn_ex or
  tau_syn_in, respectively, to avoid numerical instabilities.
  For details, please see IAF_Neruons_Singularity.ipynb in
  the NEST source code (docs/model_details).

References:
  [1] Rotter S & Diesmann M (1999) Exact simulation of time-invariant linear
      systems with applications to neuronal modeling. Biologial Cybernetics
      81:381-402.
  [2] Diesmann M, Gewaltig M-O, Rotter S, & Aertsen A (2001) State space
      analysis of synchronous spiking in cortical neural networks.
      Neurocomputing 38-40:565-571.
  [3] Morrison A, Straube S, Plesser H E, & Diesmann M (2006) Exact subthreshold
      integration with continuous spike times in discrete time neural network
      simulations. Neural Computation, in press

Sends: SpikeEvent

Receives: SpikeEvent, CurrentEvent, DataLoggingRequest
FirstVersion: September 1999
Author:  Diesmann, Gewaltig
SeeAlso: iaf_psc_delta, iaf_psc_exp, iaf_cond_exp
*/
neuron iaf_psc_alpha_neuron:
  state:
    V_abs mV
    function V_m mV = V_abs+E_L
    y1_I_shape_in real
    y2_I_shape_in real
    y1_I_shape_ex real
    y2_I_shape_ex real
  end
  equations:
    shape I_shape_in = 1*(e/tau_syn_in)*t*exp((-1)/tau_syn_in*t)
    shape I_shape_ex = 1*(e/tau_syn_ex)*t*exp((-1)/tau_syn_ex*t)
    V_abs' = (-1)/Tau*V_abs+1/C_m*(curr_sum(I_shape_in, in_spikes)+curr_sum(I_shape_ex, ex_spikes)+I_e+currents)
  end
  parameters:
    C_m pF = 250
    Tau ms = 10
    tau_syn_in ms = 2
    tau_syn_ex ms = 2
    t_ref ms = 2
    E_L mV = (-70)
    function V_reset mV = (-70)-E_L
    function Theta mV = (-55)-E_L
    I_e pA = 0
  end
  internals:
    RefractoryCounts integer = steps(t_ref)
    r integer
    __h__ ms = resolution()
    P30 real = Tau/C_m-Tau*exp((-__h__)/Tau)/C_m
    y1_I_shape_inPSCInitialValue real = e/tau_syn_in
    y1_I_shape_exPSCInitialValue real = e/tau_syn_ex
    P_I_shape_in_00 real = exp((-__h__)/tau_syn_in)
    P_I_shape_in_01 real = 0
    P_I_shape_in_02 real = 0
    P_I_shape_in_10 real = __h__*exp((-__h__)/tau_syn_in)
    P_I_shape_in_11 real = exp((-__h__)/tau_syn_in)
    P_I_shape_in_12 real = 0
    P_I_shape_in_20 real = (-Tau)*tau_syn_in*(Tau*__h__*exp(__h__/Tau)+Tau*tau_syn_in*exp(__h__/Tau)-Tau*tau_syn_in*exp(__h__/tau_syn_in)-__h__*tau_syn_in*exp(__h__/Tau))*exp((-__h__)/tau_syn_in-__h__/Tau)/(C_m*((Tau)**(2)-2*Tau*tau_syn_in+(tau_syn_in)**(2)))
    P_I_shape_in_21 real = (-Tau)*tau_syn_in*(exp(__h__/Tau)-exp(__h__/tau_syn_in))*exp((-__h__)/tau_syn_in-__h__/Tau)/(C_m*(Tau-tau_syn_in))
    P_I_shape_in_22 real = exp((-__h__)/Tau)
    P_I_shape_ex_00 real = exp((-__h__)/tau_syn_ex)
    P_I_shape_ex_01 real = 0
    P_I_shape_ex_02 real = 0
    P_I_shape_ex_10 real = __h__*exp((-__h__)/tau_syn_ex)
    P_I_shape_ex_11 real = exp((-__h__)/tau_syn_ex)
    P_I_shape_ex_12 real = 0
    P_I_shape_ex_20 real = (-Tau)*tau_syn_ex*(Tau*__h__*exp(__h__/Tau)+Tau*tau_syn_ex*exp(__h__/Tau)-Tau*tau_syn_ex*exp(__h__/tau_syn_ex)-__h__*tau_syn_ex*exp(__h__/Tau))*exp((-__h__)/tau_syn_ex-__h__/Tau)/(C_m*((Tau)**(2)-2*Tau*tau_syn_ex+(tau_syn_ex)**(2)))
    P_I_shape_ex_21 real = (-Tau)*tau_syn_ex*(exp(__h__/Tau)-exp(__h__/tau_syn_ex))*exp((-__h__)/tau_syn_ex-__h__/Tau)/(C_m*(Tau-tau_syn_ex))
    P_I_shape_ex_22 real = exp((-__h__)/Tau)
    __P01 real = exp(((-__h__))/tau_syn_in)
    __P11 real = exp(((-__h__))/tau_syn_in)
    __P21 real = exp(((-__h__))/tau_syn_ex)
    __P31 real = exp(((-__h__))/tau_syn_ex)
  end
  input:
    ex_spikes <- excitatory spike
    in_spikes <- inhibitory spike
    currents <- current
  end
  output: spike
  update:
    if r==0: # neuron not refractory
      V_abs = P30*(I_e+currents)+V_abs*exp((-__h__)/Tau)
      V_abs += P_I_shape_in_20*y1_I_shape_in+P_I_shape_in_21*y2_I_shape_in
      V_abs += P_I_shape_ex_20*y1_I_shape_ex+P_I_shape_ex_21*y2_I_shape_ex
    else: # neuron is absolute refractory
      r = r-1
    end
    if V_abs>=Theta: # threshold crossing
      # A supra-threshold membrane potential should never be observable.# The reset at the time of threshold crossing enables accurate# integration independent of the computation step size, see [2,3] for# details.
      r = RefractoryCounts
      V_abs = V_reset
      emit_spike()
    end
    y2_I_shape_in = (__h__*y1_I_shape_in+y2_I_shape_in)*__P01
    y1_I_shape_in = y1_I_shape_in*__P11
    y2_I_shape_ex = (__h__*y1_I_shape_ex+y2_I_shape_ex)*__P21
    y1_I_shape_ex = y1_I_shape_ex*__P31
    y1_I_shape_in += y1_I_shape_inPSCInitialValue*in_spikes
    y1_I_shape_ex += y1_I_shape_exPSCInitialValue*ex_spikes
  
  end
end
